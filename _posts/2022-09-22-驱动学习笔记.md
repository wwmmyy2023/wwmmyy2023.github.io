---
layout:     post
title:      Linux 驱动学习笔记
subtitle:   
date:       2022-09-22-驱动学习笔记
author:     WMY
header-img: img/tag-bg.jpg
catalog: true
tags:
    - 工作
---


## gcc常用命令汇总:

	-E: 预处理  -I: 头文件路径
	-S:编译成汇编文件 -g:调试
	-c:汇编 -O:优化
	-l:链接库 -Wall:打开警告
	-L:链接库路径 -D:添加宏定义
	
	gcc -E test.c -o test-i
	gcc -S test.c -o test.s
	gcc -c test.c -o test.o
	gcc test.c -o pthread.o -lpthread
	gcc test.c -o hello -ltest -L .  //表示加上自己链接库及其路径
	gcc test.c -o hello -I .. //链接头文件路径 不在当前路径下的
	gcc test.c -o hello -g  //支持gdb调试的编译结果
	gcc test.c -o hello -O3
	gcc test.c -o hello -Wall //打开编译时所有的警告
	gcc test.c -o hello -DHELLO //表示添加宏定义

## 1.驱动学习，hello world:

	//test.c 文件:
	#include <linux/init.h>
	#include <linux/module.h>
	
	static int hello_init(void) 
	{
		printk(KERN_ALERT "Hello World enter\n");
		return 0;
	}
	
	static void hello_exit(void)
	{
		printk(KERN_ALERT "Hello World exit\n");
	}
	
	module_init(hello_init);
	module_exit(hello_exit);
	MODULE_LICENSE("GPL");

对应的Makefile文件:

	KERNELDIR = /lib/modules/$(shell uname -r)/build
	CURDIR = $(shell pwd)
	MOD_NAME=test
	
	all: 
	
		make -C $(KERNELDIR) M=$(CURDIR) modules
	
	clean:
		
		rm -rf *.o *.mod.c $(MOD_NAME).mod $(MOD_NAME).ko Module.symvers modules.order .*.cmd .tmp_versions
	
	obj-m += $(MOD_NAME).o

执行命令:

	启动编译:输入make
	清理编译结果文件及中间件: make clean
	加载编译出来的ko文件: insmod test.ko
	卸载编译出来的ko文件: rmmod test.ko
	查看执行log日志文件: dmesg 
	查看编译模块ko信息: modinfo test.ko

Makefile,.config,Kconfig文件的关系:

	用做菜类比他们之间的关系:
	Makefile 文件相当于菜的做法。
	Kconfig文件相当于饭店的菜单
	.config文件相当于我们使用饭店的菜单点完的菜品




## 2.驱动传参测试:

	//test.c
	#include <linux/init.h>
	#include <linux/module.h>
	#include <linux/moduleparam.h>
	
	static int a =0;
	static int array[5]={1};
	static int array_size1;
	static char str1[10]={0};
	
	module_param(a,int,S_IRUGO);
	MODULE_PARM_DESC(a,"e.g:a=1");
	
	module_param_array(array,int,&array_size1,S_IRUGO); //驱动传参传递数组
	MODULE_PARM_DESC(array,"e.g:array=1,2,3");
	
	module_param_string(str,str1,sizeof(str1),S_IRUGO); //驱动传参传递字符
	MODULE_PARM_DESC(str,"e.g:str=hello");
	
	
	static int hello_init(void) 
	{
		int i=0;
		printk(KERN_ALERT "Hello World enter\n");
		printk("a is %d\n",a);
	
		for(i=0;i<array_size1;i++){
			printk("array[%d] is %d\n",i,array[i]);
		}
		printk("array size is:%d\n",array_size1);
	
		printk("str1 is:%s\n",str1);
	
		return 0;
	}
	
	static void hello_exit(void)
	{
		printk(KERN_ALERT "Hello World exit\n");
	}
	
	module_init(hello_init);
	module_exit(hello_exit);
	MODULE_LICENSE("GPL");


	#Makefile文件:
	KERNELDIR = /lib/modules/$(shell uname -r)/build
	CURDIR = $(shell pwd)
	MOD_NAME=test
	all: 
		make -C $(KERNELDIR) M=$(CURDIR) modules
	clean:	
		rm -rf *.o *.mod.c $(MOD_NAME).mod $(MOD_NAME).ko Module.symvers modules.order .*.cmd .tmp_versions
	obj-m += $(MOD_NAME).o

执行命令:

	sudo insmod test.ko a=1 array=1,2,3 str=nihao world

dmesg输出结果:

	[31484.031778] a is 1
	[31484.031779] array[0] is 1
	[31484.031780] array[1] is 2
	[31484.031781] array[2] is 3
	[31484.031782] array size is:3
	[31484.031783] str1 is:nihao


## 3.字符驱动设备号申请
	
	#include <linux/init.h>
	#include <linux/module.h>
	#include <linux/moduleparam.h>
	#include <linux/fs.h>
	#include <linux/kdev_t.h>
	
	static int major = 0;
	static int minor = 0;
	
	module_param(major,int,S_IRUGO);
	module_param(minor,int,S_IRUGO);
	
	dev_t dev_num;
	
	static int hello_init(void) 
	{
		int ret;
		printk(KERN_ALERT "Hello World enter\n");
		if(major) { //这里是想通过驱动传参传递设备号进来做测试
			printk("major is %d\n",major);
			printk("minor is %d\n",minor);
			dev_num = MKDEV(major,minor); //组成设备号方式
			ret = register_chrdev_region(dev_num,1,"char_dev_name"); //参数1:设备号起始值。参数2:次设备号数量。参数3:设别号名称
			if(ret<0){
				printk("register char dev is error!\n");
				return -1;
			}
			printk("register char dev is ok!\n");
		}else {
			ret = alloc_chrdev_region(&dev_num,0,1,"alloc_chardev_name"); //参数1:保存自动申请的设备号。参数2:次设备起始地址。参数3:要申请的设别号数量。参数4:设备号名称
			if(ret <0){
			    printk("alloc char dev is error!\n");
			} else {
			    printk("alloc char dev is ok\n");
			    major= MAJOR(dev_num);
			    minor= MINOR(dev_num);
			    printk("major is %d, minor is %d\n",major,minor);
			}
	
		}
		return 0;
	}
	
	static void hello_exit(void)
	{
		unregister_chrdev_region(dev_num,1);
		printk(KERN_ALERT "Hello World exit\n");
	}
	
	module_init(hello_init);
	module_exit(hello_exit);
	MODULE_LICENSE("GPL");

1.动态申请设备号:

	sudo insmod test.ko

	[37872.823767] Hello World enter
	[37872.823772] alloc char dev is ok
	[37872.823773] major is 240, minor is 0

通过 cat /proc/devices 能看到如下信息:

	240 alloc_chardev_name

2.静态申请设备号:

	sudo insmod test.ko  major=260 minor=0

dmesg输出结果:

	[42076.984013] Hello World enter
	[42076.984016] major is 260
	[42076.984018] minor is 0
	[42076.984019] register char dev is ok!

通过 cat /proc/devices 能看到如下信息:

	260 char_dev_name


## 4.手动创建字符设备节点及应用程序访问

设备节点是应用程序和驱动程序沟通的一个桥梁。Linux可通过主设备号找到他对应的file_operations结构体。通过次设备号找到这个设备是同类设备中的第几个。

下面是用到的主要结构体及函数说明：

	`struct cdev` 是 Linux 内核中的一个结构体，用于表示字符设备。下面是 `struct cdev` 的参数说明：
		- `kobject kobj`：一个内核对象，用于表示字符设备对象的内核对象。
		- `struct module *owner`：指向拥有该字符设备的内核模块的指针。
		- `const struct file_operations *ops`：指向 `struct file_operations` 结构体的指针，用于定义字符设备的操作函数。
		- `struct list_head list`：一个链表节点，用于将字符设备添加到全局字符设备列表中。
		- `dev_t dev`：用于表示字符设备的设备号。
		- `unsigned int count`：表示字符设备的引用计数。
		- `struct mutex mutex`：一个互斥锁，用于保护字符设备的访问。
		- `unsigned int flags`：表示字符设备的标志位。

	cdev_add 是一个函数，用于将一个 struct cdev 结构体表示的字符设备添加到系统中。下面是 cdev_add 函数的参数说明：
		struct cdev *p：指向 struct cdev 结构体的指针，表示要添加的字符设备。
		dev_t dev：表示要添加的字符设备的设备号。
		unsigned int count：表示要添加的字符设备的数量。

	struct file_operations 用于定义字符设备的操作函数，是字符设备驱动程序中最重要的数据结构之一。作用是将字符设备的操作函数与相应的操作关联起来，使应用程序可以通过系统调用来访问和操作字符设备。

		下面是 struct file_operations 结构体的完整参数说明：

		loff_t (*llseek) (struct file *, loff_t, int)：实现文件偏移量的设置和获取。返回新的文件偏移量。
		ssize_t (*read) (struct file *, char __user *, size_t, loff_t *)：从设备中读取数据。返回实际读取的字节数。
		ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *)：向设备中写入数据。返回实际写入的字节数。
		int (*open) (struct inode *, struct file *)：打开设备。返回打开设备的状态。
		int (*release) (struct inode *, struct file *)：关闭设备。返回关闭设备的状态。
		long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long)：设备的控制操作。返回控制操作的结果。
		int (*mmap) (struct file *, struct vm_area_struct *)：将设备映射到用户空间。返回映射结果。
		int (*flush) (struct file *, fl_owner_t id)：刷新设备缓冲区。返回刷新结果。
		int (*fsync) (struct file *, loff_t, loff_t, int datasync)：同步文件数据到设备。返回同步结果。
		int (*aio_read) (struct kiocb *, const struct iovec *, unsigned long, loff_t)：异步读取操作。返回读取结果。
		int (*aio_write) (struct kiocb *, const struct iovec *, unsigned long, loff_t)：异步写入操作。返回写入结果。
		int (*readdir) (struct file *, void *, filldir_t)：读取目录项。返回读取结果。

代码案例展示：

	//创建字符设备，实现file_operations接口:
	#include <linux/init.h>
	#include <linux/module.h>
	#include <linux/moduleparam.h>
	#include <linux/fs.h>
	#include <linux/kdev_t.h>
	#include <linux/cdev.h>
	
	dev_t dev_num;
	
	struct cdev cdev_test;
	
	static int cdev_test_open(struct inode *inode, struct file *file){
		printk("cdev_test_open\n");
		return 0;
	}
	
	static ssize_t cdev_test_read(struct file *file, char __user *buf, size_t size, loff_t *off){
		printk("cdev_test_read\n");
		return 0;
	}
	
	static ssize_t cdev_test_write(struct file *file, const char __user *buf, size_t size, loff_t *off){
		printk("cdev_test_write\n");
		return 0;
	}
	
	static int cdev_test_release(struct inode *inode, struct file *file){
		printk("cdev_test_release\n");
		return 0;
	}
	
	struct file_operations cdev_test_ops = {
		.owner=THIS_MODULE,
		.open=cdev_test_open,
		.read=cdev_test_read,
		.write=cdev_test_write,
		.release=cdev_test_release
	};
	
	static int hello_init(void) 
	{
		int ret;
		int major=0;
		int minor=0;
		printk(KERN_ALERT "Hello World enter\n");
		ret = alloc_chrdev_region(&dev_num,0,1,"alloc chardev name3"); //动态申请字符设备号
		if(ret <0){
			printk("alloc char dev is error!\n");
		} else {
			printk("alloc char dev is ok\n");
			major= MAJOR(dev_num);
			minor= MINOR(dev_num);
			printk("major is %d, minor is %d\n",major,minor);		
			cdev_test.owner=THIS_MODULE;
			cdev_init(&cdev_test,&cdev_test_ops); //用于初始化cdev结构体成员，建立cdev和file_operations之间的联系
			cdev_add(&cdev_test,dev_num,1); //向系统添加一个cdev结构体，即添加一个字符设备。也就是建立设备号和cdev的关联。
		}
	
		return 0;
	}
	
	static void hello_exit(void)
	{
		unregister_chrdev_region(dev_num,1);
		cdev_del(&cdev_test);
		printk(KERN_ALERT "Hello World exit\n");
	}
	
	module_init(hello_init);
	module_exit(hello_exit);
	MODULE_LICENSE("GPL");


加载ko驱动程序：
	sudo insmod test.ko

显示生成的主次设备号为：
	[42576.984016] major is 238
	[42576.984018] minor is 0
或通过命令也可以查看到：
	cat /proc/devices
	238 alloc chardev name3

根据生成的设备号创建虚拟字符设备节点作为桥梁，下面是手动创建设备节点：

	sudo mknod /dev/test c 238 0
	ls /dev/test -al 
	输出结果:crw-r--r-- 1 root root 238, 0 6月  11 19:21 /dev/test

创建测试客户端应用程序访问该节点:

	#include <stdio.h>
	#include <sys/types.h>
	#include <sys/stat.h>
	#include <fcntl.h>
	#include <unistd.h>
	
	int main(int argc,char *argv[]){
		int fd;
		char buf[64] = {0};
		fd = open("/dev/test",O_RDWR);
		if(fd<0){
			perror("open error\n");
			return fd;
		}
		close(fd);
		return 0;	
	}

指定该测试客户端程序:

	sudo ./a.out

然后执行dmesg查看打印:

	[45723.035724] cdev_test_open
	[45723.035727] cdev_test_release


## 5.自动创建设备节点及于内核数据交互

自动创建设备节点时用到的主要结构体及函数说明：
	
	class_create 和 device_create 是 Linux 内核中用于创建设备类和设备节点的函数。它们通常在字符设备驱动程序中使用。下面是这两个函数的说明：
		class_create 函数：
		函数原型：struct class *class_create(struct module *owner, const char *name);
		功能：创建一个设备类（struct class 对象）。
		参数：
		owner：指向拥有该设备类的内核模块的指针。
		name：设备类的名称，通常是在 /sys/class/ 目录下创建的一个子目录。
		返回值：指向创建的设备类对象的指针。

	device_create 函数：
		函数原型：struct device *device_create(struct class *class, struct device *parent, dev_t dev, void *drvdata, const char *fmt, ...);
		功能：在指定的设备类下创建一个设备节点。
		参数：
		class：指向要创建设备节点的设备类对象的指针。
		parent：指向父设备节点对象的指针，通常为 NULL。
		dev：设备节点的设备号。
		drvdata：与设备节点关联的驱动程序数据，通常为 NULL。
		fmt：设备节点名称的格式字符串。
		...：格式字符串中的参数，用于生成设备节点名称。
		返回值：指向创建的设备节点对象的指针。

	测试方法同上一节，只是不用再手动mknod创建节点了

	//1.驱动端程序
	#include <linux/init.h>
	#include <linux/module.h>
	#include <linux/moduleparam.h>
	#include <linux/fs.h>
	#include <linux/kdev_t.h>
	
	#include <linux/cdev.h>
	#include <linux/device.h>
	
	#include <linux/uaccess.h>
	
	dev_t dev_num;
	
	struct cdev cdev_test;
	
	struct class *class;
	struct device *device;
	
	static int cdev_test_open(struct inode *inode, struct file *file){
		printk("cdev_test_open\n");
		return 0;
	}
	
	static ssize_t cdev_test_read(struct file *file, char __user *buf, size_t size, loff_t *off){
		char kbuf[32] = "cdev_test_read\n";
		if(copy_to_user(buf,kbuf,strlen(kbuf)) !=0) {
			printk("cdev_test_read error!\n");
			return -1;
		}
		printk("cdev_test_read\n");
		return 0;
	}
	
	static ssize_t cdev_test_write(struct file *file, const char __user *buf, size_t size, loff_t *off){
		char kbuf[32] = {0};
		if(copy_from_user(kbuf,buf,size) !=0) {
			printk("cdev_test_write error!\n");
			return -1;
		}
		printk("cdev_test_write kbuf is:%s\n", kbuf);
		return 0;
	}
	
	static int cdev_test_release(struct inode *inode, struct file *file){
		printk("cdev_test_release\n");
		return 0;
	}
	
	struct file_operations cdev_test_ops = {
		.owner=THIS_MODULE,
		.open=cdev_test_open,
		.read=cdev_test_read,
		.write=cdev_test_write,
		.release=cdev_test_release
	};
	
	static int hello_init(void) 
	{
		int ret;
		int major=0;
		int minor=0;
		printk(KERN_ALERT "Hello World enter\n");
		ret = alloc_chrdev_region(&dev_num,0,1,"alloc chardev name3");
		if(ret <0){
			printk("alloc char dev is error!\n");
		} else {
			printk("alloc char dev is ok\n");
			major= MAJOR(dev_num);
			minor= MINOR(dev_num);
			printk("major is %d, minor is %d\n",major,minor);
			
			cdev_test.owner=THIS_MODULE;
			cdev_init(&cdev_test,&cdev_test_ops);
			cdev_add(&cdev_test,dev_num,1);
			
			
			class = class_create(THIS_MODULE,"test"); //函数原型：struct class *class_create(struct module *owner, const char *name); name设备类的名称，通常是在 /sys/class/ 目录下创建的一个子目录。
			device = device_create(class,NULL,dev_num,NULL,"test"); //这个会创建一个 /dev/test节点
		}
	
		return 0;
	}
	
	static void hello_exit(void)
	{
		unregister_chrdev_region(dev_num,1);
		cdev_del(&cdev_test);
		device_destroy(class,dev_num);
		class_destroy(class);
		printk(KERN_ALERT "Hello World exit\n");
	}
	
	module_init(hello_init);
	module_exit(hello_exit);
	MODULE_LICENSE("GPL");

	//2.测试端程序
	#include <stdio.h>
	#include <sys/types.h>
	#include <sys/stat.h>
	#include <fcntl.h>
	#include <unistd.h>
	
	int main(int argc,char *argv[]){
		int fd;
		char buf[32] = {0};
		
		char buf2[32] = "hello user write";
		fd = open("/dev/test",O_RDWR);
		if(fd<0){
			perror("open error\n");
			return fd;
		}
		read(fd,buf,sizeof(buf));
		printf("user read buf is:%s", buf);
		write(fd,buf2,sizeof(buf2));
		close(fd);
		return 0;	
	}


加载ko:
 sudo insmod test.ko

执行 sudo ./a.out 打印:

	user read buf is:cdev_test_read

dmesg 或者 cat /proc/kmsg 命令打印:

	[47987.816881] cdev_test_open
	[47987.816885] cdev_test_read
	[47987.817121] cdev_test_write kbuf is:hello user write
	[47987.817123] cdev_test_release


## 6.字符设备驱动私有数据使用

用到的主要结构体及函数说明：
	`container_of` 是一个宏，用于在结构体中获取包含某个成员的结构体的指针。它常用于内核开发中，用于从某个成员的指针反推出包含该成员的结构体的指针。

	下面是 `container_of` 宏的参数说明：

	- `ptr`：指向某个成员的指针。
	- `type`：包含该成员的结构体类型。
	- `member`：该成员在结构体中的名称。


	//1.驱动代码
	#include <linux/init.h>
	#include <linux/module.h>
	#include <linux/moduleparam.h>
	#include <linux/fs.h>
	#include <linux/kdev_t.h>
	
	#include <linux/cdev.h>
	#include <linux/device.h>
	
	#include <linux/uaccess.h>
	#inlcude <linux/errno.h>
	
	struct device_test {
		dev_t dev_num;
		int major;
		int minor;
		struct cdev cdev_test;
		struct class *class;
		struct device *device;
		char kbuf[32];
	};
	
	struct device_test dev1;
	struct device_test dev2;
	
	static int cdev_test_open(struct inode *inode, struct file *file){
		//dev1.minor = 0;
		//dev2.minor = 1; //用于实验测试
		file->private_data=container_of(inode->i_cdev, struct device_test, cdev_test); //struct inode 是 Linux 内核中表示文件或目录的数据结构，它包含了文件或目录的元数据信息,定义在linux/fs.h中。i_cdev指向struct cdev 结构体的指针,struct cdev 表示字符设备，包含了字符设备的操作函数和其他相关信息。	该处操作可以在open文件时将其cdev信息存储到private_data中，进而后续的read 和write函数可以用到	
		printk("cdev_test_open\n");
		return 0;
	}
	
	static ssize_t cdev_test_read(struct file *file, char __user *buf, size_t size, loff_t *off){
		struct device_test* test_dev = (struct device_test*)file->private_data; //file->private_data 是 struct file 结构体中的一个成员，用于存储与该文件相关的私有数据
		if(copy_to_user(buf,test_dev->kbuf,strlen(test_dev->kbuf)) !=0) {
			printk("cdev_test_read error!\n");
			return -1;
		}
		printk("cdev_test_read\n");
		return 0;
	}
	
	static ssize_t cdev_test_write(struct file *file, const char __user *buf, size_t size, loff_t *off){
		struct device_test* test_dev = (struct device_test*)file->private_data;
		if(test_dev->minor==0){
			if(copy_from_user(test_dev->kbuf,buf,size) !=0) {
				printk("cdev_test_write error!\n");
				return -1;
			}
			printk("cdev_test_write kbuf1 is:%s\n", test_dev->kbuf);
		} else if(test_dev->minor ==1){
			if(copy_from_user(test_dev->kbuf,buf,size) !=0) {
				printk("cdev_test_write error!\n");
				return -1;
			}
			printk("cdev_test_write kbuf2 is:%s\n", test_dev->kbuf);
		}
			
		return 0;
	}
	
	static int cdev_test_release(struct inode *inode, struct file *file){
		printk("cdev_test_release\n");
		return 0;
	}
	
	struct file_operations cdev_test_ops = {
		.owner=THIS_MODULE,
		.open=cdev_test_open,
		.read=cdev_test_read,
		.write=cdev_test_write,
		.release=cdev_test_release
	};
	
	static int hello_init(void) 
	{
		int ret;
		printk(KERN_ALERT "Hello World enter\n");
		ret = alloc_chrdev_region(&dev1.dev_num,0,2,"alloc chardev name3");
		if(ret <0){
			printk("alloc char dev is error!\n");
		} else {
			printk("alloc char dev is ok\n");
			dev1.major= MAJOR(dev1.dev_num);
			dev1.minor= MINOR(dev1.dev_num);
			printk("dev1 major is %d, minor is %d\n",dev1.major,dev1.minor);
			
			dev1.cdev_test.owner=THIS_MODULE;
			cdev_init(&dev1.cdev_test,&cdev_test_ops);
			cdev_add(&dev1.cdev_test,dev1.dev_num,1);		
			
			dev1.class = class_create(THIS_MODULE,"test1");
			dev1.device = device_create(dev1.class,NULL,dev1.dev_num,NULL,"test1");
			if(IS_ERR(dev1.device)) {
				ret = PTR_ERR(dev1.device);
			}

			dev2.major= MAJOR(dev1.dev_num+1);
			dev2.minor= MINOR(dev1.dev_num+1);
			printk("dev2 major is %d, minor is %d\n",dev2.major,dev2.minor);
			
			dev2.cdev_test.owner=THIS_MODULE;
			cdev_init(&dev2.cdev_test,&cdev_test_ops);
			cdev_add(&dev2.cdev_test,dev1.dev_num+1,1);		
			
			dev2.class = class_create(THIS_MODULE,"test2");
			dev2.device = device_create(dev2.class,NULL,dev1.dev_num+1,NULL,"test2");
		}
	
		return 0;
	}
	
	static void hello_exit(void)
	{
		unregister_chrdev_region(dev1.dev_num,1);
		unregister_chrdev_region(dev1.dev_num+1,1);
		cdev_del(&dev1.cdev_test);
		cdev_del(&dev2.cdev_test);
		
		device_destroy(dev1.class,dev1.dev_num);
		device_destroy(dev2.class,dev1.dev_num+1);
		class_destroy(dev1.class);
		class_destroy(dev2.class);
		printk(KERN_ALERT "Hello World exit\n");
	}
	
	module_init(hello_init);
	module_exit(hello_exit);
	MODULE_LICENSE("GPL");


	//2.测试代码:
	#include <stdio.h>
	#include <sys/types.h>
	#include <sys/stat.h>
	#include <fcntl.h>
	#include <unistd.h>
	
	int main(int argc,char *argv[]){
		int fd;
		char buf1[32] = "nihao /dev/test1";
		char buf2[32] = "nihao /dev/test2";
		fd = open("/dev/test1",O_RDWR);
		if(fd<0){
			perror("open error\n");
			return fd;
		}
		write(fd,buf1,sizeof(buf1));
		close(fd);
		
		fd = open("/dev/test2",O_RDWR);
		if(fd<0){
			perror("open error\n");
			return fd;
		}
		write(fd,buf2,sizeof(buf2));
		close(fd);
		
		return 0;	
	}

执行命令:

	sudo insmod test.ko
	sudo ./a.out
打印数据:

	[53726.504991] Hello World enter
	[53726.504995] alloc char dev is ok
	[53726.504996] dev1 major is 237, minor is 0
	[53726.506036] dev2 major is 237, minor is 1
	[53740.434641] cdev_test_open
	[53740.434644] cdev_test_write kbuf1 is:nihao /dev/test1
	[53740.434646] cdev_test_release
	[53740.434651] cdev_test_open
	[53740.434654] cdev_test_write kbuf2 is:nihao /dev/test2
	[53740.434655] cdev_test_release
	
	  ls /dev/test1 -al 
	crw------- 1 root root 237, 0 6月  11 21:36 /dev/test1
	  ls /dev/test2 -al 
	crw------- 1 root root 237, 1 6月  11 21:36 /dev/test2



## 7.杂项设备驱动
杂项设备驱动将主设备号固定成为10，不会在消耗一个主设备号。它会自己创建设备节点，它是字符设备驱动的进一步封装。

	//1.驱动代码
	#include <linux/init.h>
	#include <linux/module.h>
	#include <linux/moduleparam.h>
	#include <linux/fs.h>
	#include <linux/kdev_t.h>
	
	#include <linux/cdev.h>
	#include <linux/device.h>
	
	#include <linux/uaccess.h>
	#include <linux/miscdevice.h>
	
	
	static int cdev_test_open(struct inode *inode, struct file *file){	
		printk("cdev_test_open\n");
		return 0;
	}
	
	static ssize_t cdev_test_read(struct file *file, char __user *buf, size_t size, loff_t *off){
		printk("cdev_test_read\n");
		return 0;
	}
	
	static ssize_t cdev_test_write(struct file *file, const char __user *buf, size_t size, loff_t *off){
		printk("cdev_test_write buf is:%s\n", buf);
		return 0;
	}
	
	static int cdev_test_release(struct inode *inode, struct file *file){
		printk("cdev_test_release\n");
		return 0;
	}
	
	struct file_operations cdev_test_ops = {
		.owner=THIS_MODULE,
		.open=cdev_test_open,
		.read=cdev_test_read,
		.write=cdev_test_write,
		.release=cdev_test_release
	};
	
	struct miscdevice misc_dev={
		.minor = MISC_DYNAMIC_MINOR,
		.name = "mymiscdevicetest", //这里是定义的设备节点的名称
		.fops = &cdev_test_ops
	};
	
	static int hello_init(void) 
	{
		int ret;
		ret = misc_register(&misc_dev); //注册
		if(ret<0){
			printk("misc_register error");
			return -1;
		}
		
		return 0;
	}
	
	static void hello_exit(void)
	{
		printk(KERN_ALERT "Hello World exit\n");
		misc_deregister(&misc_dev); //卸载
	}
	
	module_init(hello_init);
	module_exit(hello_exit);
	MODULE_LICENSE("GPL");


加载后打印结果:

	sudo insmod test.ko
	ls -al /dev/mymiscdevicetest
	crw------- 1 root root 10, 56 6月  11 21:55 /dev/mymiscdevicetest

错误码信息:

	#inlcude <linux/errno.h>
	if(IS_ERR(dev1.device)) {
		ret = PTR_ERR(dev1.device);
		goto xxxx;
	}

#### 字符设备驱动框架总结：

	1.注册字符设备
	 1.1 分配设备号
		1.1.1 静态分配设备号--register_chrdev_region
		1.1.2 动态分配设备号--alloc_chrdev_region
		1.1.3 操作设备号dev_t
			1.1.3.1 宏MAJOR用于从dev_t中获取主设备号
			1.1.3.2 宏MINOR用于从dev_t中获取次设备号
			1.1.3.3 宏MKDEV用于将给定的主设备号和次设备号的值组合成dev_t类型的设备号
	 1.2 初始化cdev--cdev_init
	 1.3 注册cdev--cdev_add

	2.构建file_operations结构体
	 2.1 open私有数据
	 2.2 read--copy_to_user
	 2.3 write--copy_from_user
	 2.4 close

	3.生成设备节点
	 3.1 自动生成设别节点
		3.1.1 创建class--class_create
		3.1.2 创建设别--device_create
	 3.2 手动生成设备节点--maknod命令
	 
	4.驱动卸载
	 4.1 释放设备号--unregister_chrdev_region
	 4.2 卸载cdev--cdev_del
	 4.3 卸载设备--device_destroy
	 4.4 卸载class--class_destroy 
	 
 

## 8. 并发与竞争

### 8.1.原子操作

	#include <linux/init.h>
	#include <linux/module.h>
	#include <linux/moduleparam.h>
	#include <linux/fs.h>
	#include <linux/kdev_t.h>
	
	#include <linux/cdev.h>
	#include <linux/device.h>
	
	#include <linux/uaccess.h>
	#include <linux/errno.h>
	
	#include <linux/atomic.h>
	#include <asm/atomic.h>
	
	struct device_test {
		dev_t dev_num;
		int major;
		int minor;
		struct cdev cdev_test;
		struct class *class;
		struct device *device;
		char kbuf[32];
	};
	
	struct device_test dev1;
	static atomic64_t v=ATOMIC_INIT(1);
	
	
	static int cdev_test_open(struct inode *inode, struct file *file) {
		printk("cdev_test_open\n");
		// atomic64_dec_and_test(&v) //原子地从v减1，如果结果等于0，返回真；否则返回假
		if(!atomic64_dec_and_test(&v)){
			atomic64_inc(&v);
			return -EBUSY;
		}
	
		dev1.minor = 0;
		file->private_data=container_of(inode->i_cdev, struct device_test, cdev_test);
		
		return 0;
	}
	
	static ssize_t cdev_test_read(struct file *file, char __user *buf, size_t size, loff_t *off){
		struct device_test* test_dev = (struct device_test*)file->private_data;
		if(copy_to_user(buf,test_dev->kbuf,strlen(test_dev->kbuf)) !=0) {
			printk("cdev_test_read error!\n");
			return -1;
		}
		printk("cdev_test_read\n");
		return 0;
	}
	
	static ssize_t cdev_test_write(struct file *file, const char __user *buf, size_t size, loff_t *off){
		struct device_test* test_dev = (struct device_test*)file->private_data;
		if(test_dev->minor==0){
			if(copy_from_user(test_dev->kbuf,buf,size) !=0) {
				printk("cdev_test_write error!\n");
				return -1;
			}
			printk("cdev_test_write kbuf1 is:%s\n", test_dev->kbuf);
		} else if(test_dev->minor==1){
			if(copy_from_user(test_dev->kbuf,buf,size) !=0) {
				printk("cdev_test_write error!\n");
				return -1;
			}
			printk("cdev_test_write kbuf2 is:%s\n", test_dev->kbuf);
		}
			
		return 0;
	}
	
	static int cdev_test_release(struct inode *inode, struct file *file){
		printk("cdev_test_release\n");
		atomic64_inc(&v);
		return 0;
	}
	
	struct file_operations cdev_test_ops = {
		.owner=THIS_MODULE,
		.open=cdev_test_open,
		.read=cdev_test_read,
		.write=cdev_test_write,
		.release=cdev_test_release
	};
	
	static int hello_init(void) 
	{
		int ret;
		printk(KERN_ALERT "Hello World enter\n");
		ret = alloc_chrdev_region(&dev1.dev_num,0,1,"alloc chardev name3");
		if(ret <0){
			printk("alloc char dev is error!\n");
		} else {
			printk("alloc char dev is ok\n");
			dev1.major= MAJOR(dev1.dev_num);
			dev1.minor= MINOR(dev1.dev_num);
			printk("dev1 major is %d, minor is %d\n",dev1.major,dev1.minor);
			
			dev1.cdev_test.owner=THIS_MODULE;
			cdev_init(&dev1.cdev_test,&cdev_test_ops);
			cdev_add(&dev1.cdev_test,dev1.dev_num,1);		
			
			dev1.class = class_create(THIS_MODULE,"test2");
			dev1.device = device_create(dev1.class,NULL,dev1.dev_num,NULL,"test2");
		}
	
		return 0;
	}
	
	static void hello_exit(void)
	{
		unregister_chrdev_region(dev1.dev_num,1);
		cdev_del(&dev1.cdev_test);
		
		device_destroy(dev1.class,dev1.dev_num);
		class_destroy(dev1.class);
		printk(KERN_ALERT "Hello World exit\n");
	}
	
	module_init(hello_init);
	module_exit(hello_exit);
	MODULE_LICENSE("GPL");

Client端操作:

	#include <stdio.h>
	#include <sys/types.h>
	#include <sys/stat.h>
	#include <fcntl.h>
	#include <unistd.h>
	
	int main(int argc,char *argv[]){
		int fd;
		char buf1[32] = "nihao /dev/test2";
		fd = open("/dev/test2",O_RDWR);
		if(fd<0){
			perror("open error\n");
			return fd;
		}
		// write(fd,buf1,sizeof(buf1));
		sleep(5);
		close(fd);		
		return 0;	
	}

测试代码:

	sudo ./a.out &
		[4] 2916
	
	cp a.out b.out 
	
	sudo ./b.out 
		open error
		: Device or resource busy
	
	五秒之后操作:
	sudo ./b.out 
		[4]-  已完成               sudo ./a.out

### 8.2.自旋锁

在被自旋锁保护的区域不要调用耗时操作，否则可能发生死锁；
如果中断服务函数里面要使用自旋锁，需要在驱动程序中使用 spin_lock_irqsave/spin_unlock_irqrestore 函数来申请自旋锁，阻止在执行临界区里面的代码时被中断打断

	#include <linux/init.h>
	#include <linux/module.h>
	#include <linux/moduleparam.h>
	#include <linux/fs.h>
	#include <linux/kdev_t.h>
	
	#include <linux/cdev.h>
	#include <linux/device.h>
	
	#include <linux/uaccess.h>
	#include <linux/errno.h>
	
	#include <linux/atomic.h>
	#include <asm/atomic.h>
	
	struct device_test {
		dev_t dev_num;
		int major;
		int minor;
		struct cdev cdev_test;
		struct class *class;
		struct device *device;
		char kbuf[32];
	};
	
	struct device_test dev1;
	static spinlock_t spinlock;
	static int flag=1;
	
	
	static int cdev_test_open(struct inode *inode, struct file *file) {
		printk("cdev_test_open\n");
		spin_lock(&spinlock);
		if(flag!=1){
			spin_unlock(&spinlock);
			return -EBUSY;
		}
		flag=0;
		spin_unlock(&spinlock);
	
		dev1.minor = 0;
		file->private_data=container_of(inode->i_cdev, struct device_test, cdev_test);
		
		return 0;
	}
	
	static ssize_t cdev_test_read(struct file *file, char __user *buf, size_t size, loff_t *off){
		struct device_test* test_dev = (struct device_test*)file->private_data;
		if(copy_to_user(buf,test_dev->kbuf,strlen(test_dev->kbuf)) !=0) {
			printk("cdev_test_read error!\n");
			return -1;
		}
		printk("cdev_test_read\n");
		return 0;
	}
	
	static ssize_t cdev_test_write(struct file *file, const char __user *buf, size_t size, loff_t *off){
		struct device_test* test_dev = (struct device_test*)file->private_data;
		if(test_dev->minor==0){
			if(copy_from_user(test_dev->kbuf,buf,size) !=0) {
				printk("cdev_test_write error!\n");
				return -1;
			}
			printk("cdev_test_write kbuf1 is:%s\n", test_dev->kbuf);
		} else if(test_dev->minor==1){
			if(copy_from_user(test_dev->kbuf,buf,size) !=0) {
				printk("cdev_test_write error!\n");
				return -1;
			}
			printk("cdev_test_write kbuf2 is:%s\n", test_dev->kbuf);
		}
			
		return 0;
	}
	
	static int cdev_test_release(struct inode *inode, struct file *file){
		printk("cdev_test_release\n");
		spin_lock(&spinlock);
		flag=1;
		spin_unlock(&spinlock);
		return 0;
	}
	
	struct file_operations cdev_test_ops = {
		.owner=THIS_MODULE,
		.open=cdev_test_open,
		.read=cdev_test_read,
		.write=cdev_test_write,
		.release=cdev_test_release
	};
	
	static int hello_init(void) 
	{
		int ret;
		printk(KERN_ALERT "Hello World enter\n");
		ret = alloc_chrdev_region(&dev1.dev_num,0,1,"alloc chardev name3");
		if(ret <0){
			printk("alloc char dev is error!\n");
		} else {
			printk("alloc char dev is ok\n");
			dev1.major= MAJOR(dev1.dev_num);
			dev1.minor= MINOR(dev1.dev_num);
			printk("dev1 major is %d, minor is %d\n",dev1.major,dev1.minor);
			
			dev1.cdev_test.owner=THIS_MODULE;
			cdev_init(&dev1.cdev_test,&cdev_test_ops);
			cdev_add(&dev1.cdev_test,dev1.dev_num,1);		
			
			dev1.class = class_create(THIS_MODULE,"test2");
			dev1.device = device_create(dev1.class,NULL,dev1.dev_num,NULL,"test2");
		}
	
		return 0;
	}
	
	static void hello_exit(void)
	{
		unregister_chrdev_region(dev1.dev_num,1);
		cdev_del(&dev1.cdev_test);
		
		device_destroy(dev1.class,dev1.dev_num);
		class_destroy(dev1.class);
		printk(KERN_ALERT "Hello World exit\n");
	}
	
	module_init(hello_init);
	module_exit(hello_exit);
	MODULE_LICENSE("GPL");


### 8.3.信号量

	#include <linux/init.h>
	#include <linux/module.h>
	#include <linux/moduleparam.h>
	#include <linux/fs.h>
	#include <linux/kdev_t.h>
	
	#include <linux/cdev.h>
	#include <linux/device.h>
	
	#include <linux/uaccess.h>
	#include <linux/errno.h>
	
	#include <linux/atomic.h>
	#include <asm/atomic.h>
	
	struct device_test {
		dev_t dev_num;
		int major;
		int minor;
		struct cdev cdev_test;
		struct class *class;
		struct device *device;
		char kbuf[32];
	};
	
	struct device_test dev1;
	static atomic64_t v=ATOMIC_INIT(1);
	
	static struct semaphore semlock;
	
	
	static int cdev_test_open(struct inode *inode, struct file *file) {
		printk("cdev_test_open\n");
	#if 0
		down(&semlock);
	#endif
		if(down_interruptible(&semlock)){
			return -EINTR;
		}
		dev1.minor = 0;
		file->private_data=container_of(inode->i_cdev, struct device_test, cdev_test);
		
		return 0;
	}
	
	static ssize_t cdev_test_read(struct file *file, char __user *buf, size_t size, loff_t *off){
		struct device_test* test_dev = (struct device_test*)file->private_data;
		if(copy_to_user(buf,test_dev->kbuf,strlen(test_dev->kbuf)) !=0) {
			printk("cdev_test_read error!\n");
			return -1;
		}
		printk("cdev_test_read\n");
		return 0;
	}
	
	static ssize_t cdev_test_write(struct file *file, const char __user *buf, size_t size, loff_t *off){
		struct device_test* test_dev = (struct device_test*)file->private_data;
		if(test_dev->minor==0){
			if(copy_from_user(test_dev->kbuf,buf,size) !=0) {
				printk("cdev_test_write error!\n");
				return -1;
			}
			printk("cdev_test_write kbuf1 is:%s\n", test_dev->kbuf);
		} else if(test_dev->minor==1){
			if(copy_from_user(test_dev->kbuf,buf,size) !=0) {
				printk("cdev_test_write error!\n");
				return -1;
			}
			printk("cdev_test_write kbuf2 is:%s\n", test_dev->kbuf);
		}
			
		return 0;
	}
	
	static int cdev_test_release(struct inode *inode, struct file *file){
		printk("cdev_test_release\n");
		up(&semlock);
		return 0;
	}
	
	struct file_operations cdev_test_ops = {
		.owner=THIS_MODULE,
		.open=cdev_test_open,
		.read=cdev_test_read,
		.write=cdev_test_write,
		.release=cdev_test_release
	};
	
	static int hello_init(void) 
	{
		int ret;
		printk(KERN_ALERT "Hello World enter\n");
		sema_init(&semlock,1);
		ret = alloc_chrdev_region(&dev1.dev_num,0,1,"alloc chardev name3");
		if(ret <0){
			printk("alloc char dev is error!\n");
		} else {
			printk("alloc char dev is ok\n");
			dev1.major= MAJOR(dev1.dev_num);
			dev1.minor= MINOR(dev1.dev_num);
			printk("dev1 major is %d, minor is %d\n",dev1.major,dev1.minor);
			
			dev1.cdev_test.owner=THIS_MODULE;
			cdev_init(&dev1.cdev_test,&cdev_test_ops);
			cdev_add(&dev1.cdev_test,dev1.dev_num,1);		
			
			dev1.class = class_create(THIS_MODULE,"test2");
			dev1.device = device_create(dev1.class,NULL,dev1.dev_num,NULL,"test2");
		}
	
		return 0;
	}
	
	static void hello_exit(void)
	{
		unregister_chrdev_region(dev1.dev_num,1);
		cdev_del(&dev1.cdev_test);
		
		device_destroy(dev1.class,dev1.dev_num);
		class_destroy(dev1.class);
		printk(KERN_ALERT "Hello World exit\n");
	}
	
	module_init(hello_init);
	module_exit(hello_exit);
	MODULE_LICENSE("GPL");


### 8.4.互斥锁

1.互斥锁会导致休眠，所以在中断里面不能用互斥锁

2.同一时刻只能有一个线程持有互斥锁，并且只有持有者可以解锁

3.不允许递归上锁和解锁

	#include <linux/init.h>
	#include <linux/module.h>
	#include <linux/moduleparam.h>
	#include <linux/fs.h>
	#include <linux/kdev_t.h>
	
	#include <linux/cdev.h>
	#include <linux/device.h>
	
	#include <linux/uaccess.h>
	#include <linux/errno.h>
	
	#include <linux/atomic.h>
	#include <asm/atomic.h>
	
	struct device_test {
		dev_t dev_num;
		int major;
		int minor;
		struct cdev cdev_test;
		struct class *class;
		struct device *device;
		char kbuf[32];
	};
	
	struct device_test dev1;
	static atomic64_t v=ATOMIC_INIT(1);
	
	// static struct semaphore semlock;
	static struct mutex mutexlock;
	static int flag=1;
	
	static int cdev_test_open(struct inode *inode, struct file *file) {
		printk("cdev_test_open\n");
		mutex_lock(&mutexlock);
		if(flag!=1) {
			mutex_unlock(&mutexlock);
			// return -EBUSY;
			return -EINTR;
		}
		flag=0;
		mutex_unlock(&mutexlock);
	
		dev1.minor = 0;
		file->private_data=container_of(inode->i_cdev, struct device_test, cdev_test);
		
		return 0;
	}
	
	static ssize_t cdev_test_read(struct file *file, char __user *buf, size_t size, loff_t *off){
		struct device_test* test_dev = (struct device_test*)file->private_data;
		if(copy_to_user(buf,test_dev->kbuf,strlen(test_dev->kbuf)) !=0) {
			printk("cdev_test_read error!\n");
			return -1;
		}
		printk("cdev_test_read\n");
		return 0;
	}
	
	static ssize_t cdev_test_write(struct file *file, const char __user *buf, size_t size, loff_t *off){
		struct device_test* test_dev = (struct device_test*)file->private_data;
		if(test_dev->minor==0){
			if(copy_from_user(test_dev->kbuf,buf,size) !=0) {
				printk("cdev_test_write error!\n");
				return -1;
			}
			printk("cdev_test_write kbuf1 is:%s\n", test_dev->kbuf);
		} else if(test_dev->minor==1){
			if(copy_from_user(test_dev->kbuf,buf,size) !=0) {
				printk("cdev_test_write error!\n");
				return -1;
			}
			printk("cdev_test_write kbuf2 is:%s\n", test_dev->kbuf);
		}
			
		return 0;
	}
	
	static int cdev_test_release(struct inode *inode, struct file *file){
		printk("cdev_test_release\n");
		mutex_lock(&mutexlock);
		flag=1;
		mutex_unlock(&mutexlock);
		return 0;
	}
	
	struct file_operations cdev_test_ops = {
		.owner=THIS_MODULE,
		.open=cdev_test_open,
		.read=cdev_test_read,
		.write=cdev_test_write,
		.release=cdev_test_release
	};
	
	static int hello_init(void) 
	{
		int ret;
		printk(KERN_ALERT "Hello World enter\n");
		ret = alloc_chrdev_region(&dev1.dev_num,0,1,"alloc chardev name3");
		if(ret <0){
			printk("alloc char dev is error!\n");
		} else {
			printk("alloc char dev is ok\n");
			dev1.major= MAJOR(dev1.dev_num);
			dev1.minor= MINOR(dev1.dev_num);
			printk("dev1 major is %d, minor is %d\n",dev1.major,dev1.minor);
			
			dev1.cdev_test.owner=THIS_MODULE;
			cdev_init(&dev1.cdev_test,&cdev_test_ops);
			cdev_add(&dev1.cdev_test,dev1.dev_num,1);		
			
			dev1.class = class_create(THIS_MODULE,"test2");
			dev1.device = device_create(dev1.class,NULL,dev1.dev_num,NULL,"test2");
		}
	
		return 0;
	}
	
	static void hello_exit(void)
	{
		unregister_chrdev_region(dev1.dev_num,1);
		cdev_del(&dev1.cdev_test);
		
		device_destroy(dev1.class,dev1.dev_num);
		class_destroy(dev1.class);
		printk(KERN_ALERT "Hello World exit\n");
	}
	
	module_init(hello_init);
	module_exit(hello_exit);
	MODULE_LICENSE("GPL");



### 8.5.等待队列
	wait_event_interruptible(wq,condition) //功能:可中断的阻塞队列，让调用进程进入可以中断的睡眠状态，直到condition变成真被内核唤醒或信号打断唤醒
驱动端:

	#include <linux/init.h>
	#include <linux/module.h>
	#include <linux/moduleparam.h>
	#include <linux/fs.h>
	#include <linux/kdev_t.h>
	
	#include <linux/cdev.h>
	#include <linux/device.h>
	
	#include <linux/uaccess.h>
	#include <linux/errno.h>
	
	// #include <linux/atomic.h>
	// #include <asm/atomic.h>
	#include <linux/wait.h>
	
	struct device_test {
		dev_t dev_num;
		int major;
		int minor;
		struct cdev cdev_test;
		struct class *class;
		struct device *device;
		char kbuf[32];
		int flag;
	};
	
	struct device_test dev1;
	DECLARE_WAIT_QUEUE_HEAD(read_wq);
	
	static int cdev_test_open(struct inode *inode, struct file *file) {
		printk("cdev_test_open\n");
	
		dev1.minor = 0;
		file->private_data=container_of(inode->i_cdev, struct device_test, cdev_test);
		
		return 0;
	}
	
	static ssize_t cdev_test_read(struct file *file, char __user *buf, size_t size, loff_t *off) {
		struct device_test* test_dev = (struct device_test*)file->private_data;
		printk("cdev_test_read flag %d!\n", test_dev->flag);
		wait_event_interruptible(read_wq,test_dev->flag); //可中断的阻塞等待
	
		if(copy_to_user(buf,test_dev->kbuf,strlen(test_dev->kbuf)) !=0) {
			printk("cdev_test_read error!\n");
			return -1;
		}
		test_dev->flag = 0;
		printk("cdev_test_read\n");
		return 0;
	}
	
	static ssize_t cdev_test_write(struct file *file, const char __user *buf, size_t size, loff_t *off){
		struct device_test* test_dev = (struct device_test*)file->private_data;
		if(copy_from_user(test_dev->kbuf,buf,size) !=0) {
			printk("cdev_test_write error!\n");
			return -1;
		}
		printk("cdev_test_write kbuf1 is:%s\n", test_dev->kbuf);
	
		test_dev->flag =1;
		wake_up_interruptible(&read_wq);
	
		return 0;
	}
	
	static int cdev_test_release(struct inode *inode, struct file *file){
		printk("cdev_test_release\n");
	
		return 0;
	}
	
	struct file_operations cdev_test_ops = {
		.owner=THIS_MODULE,
		.open=cdev_test_open,
		.read=cdev_test_read,
		.write=cdev_test_write,
		.release=cdev_test_release
	};
	
	static int hello_init(void) 
	{
		int ret;
		printk(KERN_ALERT "Hello World enter\n");
		ret = alloc_chrdev_region(&dev1.dev_num,0,1,"alloc chardev name3");
		if(ret <0){
			printk("alloc char dev is error!\n");
		} else {
			printk("alloc char dev is ok\n");
			dev1.major= MAJOR(dev1.dev_num);
			dev1.minor= MINOR(dev1.dev_num);
			printk("dev1 major is %d, minor is %d\n",dev1.major,dev1.minor);
			
			dev1.cdev_test.owner=THIS_MODULE;
			cdev_init(&dev1.cdev_test,&cdev_test_ops);
			cdev_add(&dev1.cdev_test,dev1.dev_num,1);		
			
			dev1.class = class_create(THIS_MODULE,"test2");
			if(IS_ERR(dev1.class)) {
				ret = PTR_ERR(dev1.class);
				goto err_class_create;
			}	
			dev1.device = device_create(dev1.class,NULL,dev1.dev_num,NULL,"test2");
			if(IS_ERR(dev1.device)) {
				ret = PTR_ERR(dev1.device);
				goto err_device_create;
			}
			dev1.flag=0;
		}
		return 0;
	
	err_device_create:
		cdev_del(&dev1.cdev_test);
	err_class_create:
		class_destroy(dev1.class);
	}
	
	static void hello_exit(void)
	{
		unregister_chrdev_region(dev1.dev_num,1);
		cdev_del(&dev1.cdev_test);
		
		device_destroy(dev1.class,dev1.dev_num);
		class_destroy(dev1.class);
		printk(KERN_ALERT "Hello World exit\n");
	}
	
	module_init(hello_init);
	module_exit(hello_exit);
	MODULE_LICENSE("GPL");

测试端1:

	#include <stdio.h>
	#include <sys/types.h>
	#include <sys/stat.h>
	#include <fcntl.h>
	#include <unistd.h>
	
	int main(int argc,char *argv[]){
		int fd;
		char buf1[32] = {0};
		fd = open("/dev/test2",O_RDWR);
		if(fd<0){
			perror("open error\n");
			return fd;
		}
		printf("read before!\n");
		read(fd,buf1,32);
		printf("read after:%s!\n",buf1);
	
		close(fd);
		printf("read file closed!\n");
		return 0;	
	}

测试端2:

	#include <stdio.h>
	#include <sys/types.h>
	#include <sys/stat.h>
	#include <fcntl.h>
	#include <unistd.h>
	
	int main(int argc,char *argv[]){
		int fd;
		char buf1[32] = "nihao /dev/test2";
		fd = open("/dev/test2",O_RDWR);
		if(fd<0){
			perror("open error\n");
			return fd;
		}
		printf("write before\n");
		write(fd,buf1,sizeof(buf1));
		printf("write after\n");
		
		close(fd);
		printf("file closed!\n");
		return 0;	
	}

测试命令:

	sudo ./read 
	read before!
	read after:nihao /dev/test2! //write执行之后才会打印该信息
	read file closed!

	sudo ./write
	write before
	write after
	file closed!





## 9 _ioctl设备驱动基础

测试命令:

	#include <stdio.h>
	#include <sys/ioctl.h>
	
	#define CMD_TEST0 _IO('L',0)   :合成没有数据传递的命令
	#define CMD_TEST1 _IO('L',1)
	#define CMD_TEST2 _IO('A',0)
	#define CMD_TEST3 _IOW('A',1,int)   :合成向驱动中写数据的命令
	#define CMD_TEST4 _IOR('A',2,int)   :合成从驱动中读取的数据命令
	#define CMD_TEST5 _IOWR('A',3,int)  :合成先写入数据再读取数据的命令
	
	int main(int argc,char *argv[]){
		printf("CMD_TEST3 type is:%ld\n", _IOC_TYPE(CMD_TEST3)); //分解去驱动中读取数据的命令
		printf("CMD_TEST3 dir is:%ld\n", _IOC_DIR(CMD_TEST3)); //分解没有数据传递的命令
		printf("CMD_TEST3 nr is:%ld\n", _IOC_NR(CMD_TEST3)); //分解向驱动中写数据的命令
		printf("CMD_TEST3 size is:%ld\n", _IOC_SIZE(CMD_TEST3)); //分解先写入再读取数据的命令
		
		return 0;
	}

输出结果:

	CMD_TEST3 type is:65
	CMD_TEST3 dir is:1
	CMD_TEST3 nr is:1
	CMD_TEST3 size is:4


### 9.1 _ioctl设备驱动操作

	#include <linux/init.h>
	#include <linux/module.h>
	#include <linux/moduleparam.h>
	#include <linux/fs.h>
	#include <linux/kdev_t.h>
	
	#include <linux/cdev.h>
	#include <linux/device.h>
	
	#include <linux/uaccess.h>
	#include <linux/miscdevice.h>
	
	#define CMD_TEST0 _IO('L',0)
	#define CMD_TEST1 _IOW('L',1,int)
	#define CMD_TEST2 _IOR('A',2,int)
	
	struct clientInfo {
		int a;
		int b;
		int c;
	};
	
	static int cdev_test_open(struct inode *inode, struct file *file){	
		printk("cdev_test_open\n");
		return 0;
	}
	
	static ssize_t cdev_test_read(struct file *file, char __user *buf, size_t size, loff_t *off){
		printk("cdev_test_read\n");
		return 0;
	}
	
	static ssize_t cdev_test_write(struct file *file, const char __user *buf, size_t size, loff_t *off){
		printk("cdev_test_write buf is:%s\n", buf);
		return 0;
	}
	
	static int cdev_test_release(struct inode *inode, struct file *file){
		printk("cdev_test_release\n");
		return 0;
	}
	
	long cdev_test_ioctl(struct file *file, unsigned int cmd, unsigned long arg) {
		int val;
		struct clientInfo test;
		switch (cmd) {
			case CMD_TEST0:
				printk("this is CMD_TEST0\n");
				break;
			case CMD_TEST1:
				printk("this is CMD_TEST1\n");
				if(copy_from_user(&test,arg,sizeof(test))!=0){
					printk("copy_from_user error");
					return -1;
				}
				printk("arg is %d\n", test.a);
				printk("arg is %d\n", test.b);
				printk("arg is %d\n", test.c);
				break;
			case CMD_TEST2:
				val=8888;	
				printk("this is CMD_TEST2\n");
				if(copy_to_user((int*)arg,&val,sizeof(val))!=0){
					printk("copy_to_user error");
				}
				break;
			default:
				break;
		}
	
		return 0;
	}
	
	struct file_operations cdev_test_ops = {
		.owner=THIS_MODULE,
		.open=cdev_test_open,
		.read=cdev_test_read,
		.write=cdev_test_write,
		.release=cdev_test_release,
		.unlocked_ioctl=cdev_test_ioctl
	};
	
	struct miscdevice misc_dev={
		.minor = MISC_DYNAMIC_MINOR,
		.name = "miscdevicetest",
		.fops = &cdev_test_ops
	};
	
	static int hello_init(void) 
	{
		int ret;
		ret = misc_register(&misc_dev);
		if(ret<0){
			printk("misc_register error");
			return -1;
		}
		
		return 0;
	}
	
	static void hello_exit(void)
	{
		printk(KERN_ALERT "Hello World exit\n");
		misc_deregister(&misc_dev);
	}
	
	module_init(hello_init);
	module_exit(hello_exit);
	MODULE_LICENSE("GPL");



test端操作:

	#include <stdio.h>
	#include <sys/types.h>
	#include <sys/stat.h>
	#include <fcntl.h>
	#include <unistd.h>
	#include <sys/ioctl.h>
	
	#define CMD_TEST0 _IO('L',0)
	#define CMD_TEST1 _IOW('L',1,int)
	#define CMD_TEST2 _IOR('A',2,int)
	
	struct clientInfo {
		int a;
		int b;
		int c;
	};
	
	int main(int argc,char *argv[]){
		int fd;
		int val;
		struct clientInfo test;
		test.a=11;
		test.b=12;
		test.c=13;
	
		unsigned int ret =0;
		fd = open("/dev/miscdevicetest",O_RDWR);
		if(fd<0) {
			printf("open error");
			return fd;
		}
		while(1) {
			ioctl(fd,CMD_TEST0);
			sleep(1);
			ioctl(fd,CMD_TEST1,&test);
			printf("test a is:%d\n",test.a);
			sleep(1);
			ioctl(fd,CMD_TEST2,&val);
			printf("val is:%d\n",val);
			sleep(1);
		}
		close(fd);
		return 0;
	}

输出结果:

	printk输出:
	[61810.063991] this is CMD_TEST0
	[61811.064114] this is CMD_TEST1
	[61811.064116] arg is 11
	[61811.064117] arg is 12
	[61811.064118] arg is 13
	[61812.064834] this is CMD_TEST2

test端输出:

	test a is:11
	val is:8888


## 10.高级字符设备进阶

### 10.1.IO多路复用poll

	#include <linux/init.h>
	#include <linux/module.h>
	#include <linux/moduleparam.h>
	#include <linux/fs.h>
	#include <linux/kdev_t.h>
	
	#include <linux/cdev.h>
	#include <linux/device.h>
	
	#include <linux/uaccess.h>
	#include <linux/errno.h>
	
	// #include <linux/atomic.h>
	// #include <asm/atomic.h>
	#include <linux/wait.h>
	#include <linux/poll.h>
	
	struct device_test {
		dev_t dev_num;
		int major;
		int minor;
		struct cdev cdev_test;
		struct class *class;
		struct device *device;
		char kbuf[32];
		int flag;
	};
	
	struct device_test dev1;
	DECLARE_WAIT_QUEUE_HEAD(read_wq);
	
	static int cdev_test_open(struct inode *inode, struct file *file) {
		printk("cdev_test_open\n");
	
		dev1.minor = 0;
		file->private_data=container_of(inode->i_cdev, struct device_test, cdev_test);
		
		return 0;
	}
	
	static ssize_t cdev_test_read(struct file *file, char __user *buf, size_t size, loff_t *off) {
		struct device_test* test_dev = (struct device_test*)file->private_data;
		printk("cdev_test_read flag %d!\n", test_dev->flag);
	
		if(file->f_flags & O_NONBLOCK) {
			if(test_dev->flag!=1){
				return -EAGAIN;
			}
		}
	
		wait_event_interruptible(read_wq,test_dev->flag); //可中断的阻塞等待
	
		if(copy_to_user(buf,test_dev->kbuf,strlen(test_dev->kbuf)) !=0) {
			printk("cdev_test_read error!\n");
			return -1;
		}
		test_dev->flag = 0;
		printk("cdev_test_read\n");
		return 0;
	}
	
	static ssize_t cdev_test_write(struct file *file, const char __user *buf, size_t size, loff_t *off){
		struct device_test* test_dev = (struct device_test*)file->private_data;
		if(copy_from_user(test_dev->kbuf,buf,size) !=0) {
			printk("cdev_test_write error!\n");
			return -1;
		}
		printk("cdev_test_write kbuf1 is:%s\n", test_dev->kbuf);
	
		test_dev->flag =1;
		wake_up_interruptible(&read_wq);
	
		return 0;
	}
	
	static int cdev_test_release(struct inode *inode, struct file *file){
		printk("cdev_test_release\n");
	
		return 0;
	}
	
	static __poll_t cdev_test_poll(struct file *file, struct poll_table_struct *p) {
		printk("cdev_test_poll\n");
		struct device_test* test_dev = (struct device_test*)file->private_data;
		__poll_t mask =0;
		poll_wait(file,&read_wq,p);
	
		if(test_dev->flag==1) {
			mask |=POLLIN;
		}
		return mask;
	}
	
	struct file_operations cdev_test_ops = {
		.owner=THIS_MODULE,
		.open=cdev_test_open,
		.read=cdev_test_read,
		.write=cdev_test_write,
		.release=cdev_test_release,
		.poll=cdev_test_poll
	};
	
	static int hello_init(void) 
	{
		int ret;
		printk(KERN_ALERT "Hello World enter\n");
		ret = alloc_chrdev_region(&dev1.dev_num,0,1,"alloc chardev name3");
		if(ret <0){
			printk("alloc char dev is error!\n");
		} else {
			printk("alloc char dev is ok\n");
			dev1.major= MAJOR(dev1.dev_num);
			dev1.minor= MINOR(dev1.dev_num);
			printk("dev1 major is %d, minor is %d\n",dev1.major,dev1.minor);
			
			dev1.cdev_test.owner=THIS_MODULE;
			cdev_init(&dev1.cdev_test,&cdev_test_ops);
			cdev_add(&dev1.cdev_test,dev1.dev_num,1);		
			
			dev1.class = class_create(THIS_MODULE,"test2");
			if(IS_ERR(dev1.class)) {
				ret = PTR_ERR(dev1.class);
				goto err_class_create;
			}	
			dev1.device = device_create(dev1.class,NULL,dev1.dev_num,NULL,"test2");
			if(IS_ERR(dev1.device)) {
				ret = PTR_ERR(dev1.device);
				goto err_device_create;
			}
			dev1.flag=0;
		}
		return 0;
	
	err_device_create:
		cdev_del(&dev1.cdev_test);
	err_class_create:
		class_destroy(dev1.class);
	}
	
	static void hello_exit(void)
	{
		unregister_chrdev_region(dev1.dev_num,1);
		cdev_del(&dev1.cdev_test);
		
		device_destroy(dev1.class,dev1.dev_num);
		class_destroy(dev1.class);
		printk(KERN_ALERT "Hello World exit\n");
	}
	
	module_init(hello_init);
	module_exit(hello_exit);
	MODULE_LICENSE("GPL");

client端读文件:

	#include <stdio.h>
	#include <sys/types.h>
	#include <sys/stat.h>
	#include <fcntl.h>
	#include <unistd.h>
	#include <poll.h>
	
	int main(int argc,char *argv[]){
		int fd;
		char buf1[32] = {0};
		struct pollfd fds[1];
		int ret;
	
		fd = open("/dev/test2",O_RDWR);
		if(fd<0){
			perror("open error\n");
			return fd;
		}
		fds[0].fd = fd;
		fds[0].events =POLLIN;
	
	
		printf("read before!\n");
		while(1) {
			ret=poll(fds,1,3000);
			if(!ret) {
				printf("timeout!!!\n");
			} else if(fds[0].revents==POLLIN) {
				read(fd,buf1,32);
				printf("read after:%s!\n",buf1);
				sleep(1);
			}
		}
	
		close(fd);
		printf("read file closed!\n");
		return 0;	
	}

write写文件:

	#include <stdio.h>
	#include <sys/types.h>
	#include <sys/stat.h>
	#include <fcntl.h>
	#include <unistd.h>
	
	int main(int argc,char *argv[]){
		int fd;
		char buf1[32] = "nihao /dev/test2";
		fd = open("/dev/test2",O_RDWR);
		if(fd<0){
			perror("open error\n");
			return fd;
		}
		printf("write before\n");
		write(fd,buf1,sizeof(buf1));
		printf("write after\n");
		
		close(fd);
		printf("file closed!\n");
		return 0;	
	}

测试命令:

	sudo ./read
		timeout!!!
		read after:nihao /dev/test2!
		read after:nihao /dev/test2!
		read after:nihao /dev/test2!
		timeout!!!
		timeout!!!
		timeout!!!
		timeout!!!

	sudo ./write
		write before
		write after
		file closed!



