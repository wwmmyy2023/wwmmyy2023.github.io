---
layout:     post
title:      踩内存专题分析
subtitle:    
date:       2017-03-06
author:     WMY
header-img: img/11.jpg
catalog: 	 true
tags: 
    - 工作
---


# 踩内存专题分析 #


## 1、概念：对不属于你的内存进行读写就是踩内存。

解决问题的难点：通常踩内存时间点和程序崩溃时间点没有任何关系，在踩内存发生时，程序并不一定马上崩溃，程序崩溃通常是在之后的某个时间点，从表象上看不出必然联系，所以该类问题很难调试；



## 2、踩内存的分类
 
### 2.1 被踩内存和踩内存的关系分类

#### 2.1.1 越界踩内存

踩坏的位置在你的内存的旁边，只是定义或申请的内存小了引起：
1)申请的内存小了，例1如下：

	char *p;
	
	p = malloc(5);
	strcpy(p, "hello");

strcpy()是复制了6个字节（包括'\0'）被p，但p只有5个字节的空间，把p后面的1个字节踩坏了。

2)定义的内存小了，例2如下：

	void func()
	{
	    int array[10];
	
	    for (i = 0; i <= 10; i++) {
	        array[i] = i;
	    }
	}

array[10]已经不属于array的了（正确的是0~9），因此也把array后面的4个字节踩坏了。

3)栈溢出

这个比较不容易被发现，通过pthread创建的线程的栈或内核栈都是固定大小的，如果函数定义的局部变量过多或函数调用过深容易发生栈溢出。

#### 2.1.2. use after free

堆申请的内存在释放之后（很可能又被分配出去了）又去使用这块内存，造成的踩内存，也是比较常见的。例3如下：

	char *p;
	
	p = malloc(6);
	strcpy(p, "hello");
	free(p); // p内存被回收了
	strcpy(p, "world"); /* p内存很可能再次被分配出去，这条语句直接把属于你的内存踩坏 */

#### 2.1.3. 随机踩内存

踩坏的位置和你的内存没有直接关系，我们把例2扩展下为例4：

	void func(int i)
	{
	    int array[10];
	
	    array[i] = i;
	    ......
	}

func()函数不会对i范围做检查，很可能传进来的i超过10，甚至是负数，无法知道踩坏的位置和你的内存位置，这种问题也最难查，因为可能每次崩溃的情况都不一样。
还有一种情况是变量、指针未初始化就使用，例5：

	void func(void)
	{
	    struct ABC_START *p;
	
	    p->name = "hello"; /* 发生踩坏 */
	}

p没有初始化，是随机值，可能直接崩溃也可能踩坏别人的内存。



### 2.2. 根据踩坏的内存的位置分类：

数据存储的位置无非有3种：全局区域（.data/.bss）、栈区域（局部变量）和堆区域（malloc申请的）。

#### 2.2.1. 堆踩坏

上面的例1就是堆踩坏，native层是通过malloc/new等申请内存，kernel层用kmalloc/vmalloc等申请内存。踩坏的内存也应该是堆内存。

#### 2.2.2. 栈踩坏

上面的例2就是栈踩坏，因为array是局部数组，定义在栈上的。栈是由一帧帧栈帧组成，每个栈帧含有：局部变量，函数返回地址，寄存器值。

#### 2.2.3. 全局变量踩坏

我们把例2修改下为例6：

	int array[10];
	
	void func()
	{
	    for (i = 0; i <= 10; i++) {
	        array[i] = i;
	    }
	}

array为全局数组，那么踩坏的内存也属于全局变量（除非array定义在全局区域的边沿），这种情况比较容易排查，问题也通常是index越界引起，可以看踩坏的内容的特征往前推导，大致推断开始踩的位置，找出对应的全局变量，检查其代码逻辑，看是否存在溢出可能。



### 2.3 根据踩坏的内存的内容分类：

2.3.1. 字符串

还是比较容易推导，可以看踩坏的字符串来自哪里，属于哪个模块，然后检查代码逻辑，查找可能的越界点。

#### 2.3.2. 图像或音频数据

以1或2个字节为单位，大块数据类似，这种情况可以检查下是否和图像或音频相关。

#### 2.3.3. 指针

如果踩坏的内容像某个地址，那么可以看下这个地址指向的位置是什么内容，以及地址属于哪块内存的，大致猜测可能的模块。

#### 2.3.4. 随机值

可能多数是这种情况，踩坏的内容杂乱无章，无从推导，只能从其他方向入手。


### 2.4 根据测试的手法分类：

#### 2.4.1 测试某些模块时发生的踩内存

很大可能和该模块相关，将范围缩小到这个模块。

#### 2.4.2 测试某些场景时发生的踩内存

这要看这个场景关联了哪些模块，再结合其他条件缩小范围。



### 2.5 根据多次复现观察的结果分类：

#### 2.5.1 踩坏位置固定

这个最简单，可以用watchpoint或MMU保护，直接抓到P点（发生踩坏的调用栈），然后分析代码逻辑

#### 2.5.2 踩坏位置的内存类型固定

位置虽然在变化，但有一定的规律可循，比如都是栈被踩坏或都是堆被踩坏，可以做些局部性的保护措施抓出问题点。

踩坏位置随机,无法得出规律，这种问题也最难查。



遇到一个踩内存的问题，首先要从多种角度提取踩内存的特征，然后反推可能的原因，再下对应的调试策略，才能顺利找出问题点。 以后会介绍如何分析踩内存问题


